{
    "version": "https://jsonfeed.org/version/1",
    "title": "夢の日記 • All posts by \"data structure (cs1951@sjtu)\" category",
    "description": "Stay hungry. Stay foolish.",
    "home_page_url": "https://conless.dev/blog",
    "items": [
        {
            "id": "https://conless.dev/blog/cs/data-structure/string/",
            "url": "https://conless.dev/blog/cs/data-structure/string/",
            "title": "数据结构（一）：字符串算法",
            "date_published": "2023-02-19T14:06:00.000Z",
            "content_html": "<h1 id=\"前缀函数与-KMP-算法\"><a href=\"#前缀函数与-KMP-算法\" class=\"headerlink\" title=\"前缀函数与 KMP 算法\"></a>前缀函数与 KMP 算法</h1><h2 id=\"前缀函数\"><a href=\"#前缀函数\" class=\"headerlink\" title=\"前缀函数\"></a>前缀函数</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>对于一个长度为 $n$ 的字符串 $s$，其最大相等前后缀长度为 $k$ 当<br>$$s[0\\cdots k-1]&#x3D;s[n-k+1\\cdots n]$$<br>且 $k$ 是满足这一条件的最大值。对于整个字符串，其前缀函数就是一个长度为 $n$ 的数组 $\\pi[n]$，其中 $\\pi[i]$ 的值为 $s[0\\cdots i]$ 的最大相等前后缀长度。特别地，规定 $\\pi[0]&#x3D;0$</p>\n<p>例如，字符串<br>$$abcdabcde$$<br>就有<br>$$\\pi&#x3D;{0,0,0,0,1,2,3,4,0}$$</p>\n<h3 id=\"前缀函数的计算\"><a href=\"#前缀函数的计算\" class=\"headerlink\" title=\"前缀函数的计算\"></a>前缀函数的计算</h3><h4 id=\"朴素算法\"><a href=\"#朴素算法\" class=\"headerlink\" title=\"朴素算法\"></a>朴素算法</h4><p>trivial $O(n^3)$</p>\n<h4 id=\"匹配优化\"><a href=\"#匹配优化\" class=\"headerlink\" title=\"匹配优化\"></a>匹配优化</h4><p>注意到相邻两项有 $\\Delta\\pi\\le 1$，这是因为<br>于是可以在朴素算法的前提下进行优化，将 $\\pi[n]$ 的枚举上界设为 $\\pi[n-1]+1$，这样一来，容易证明时间复杂度为 $O(n^2)$。</p>\n<h4 id=\"失配优化\"><a href=\"#失配优化\" class=\"headerlink\" title=\"失配优化\"></a>失配优化</h4><p>在上一个优化中，我们处理了 $\\pi_{n+1}$ 的最优情况，即完成匹配，下面讨论无法完成匹配的情况，容易发现，下一个应该尝试的长度最大为 $\\pi_{\\pi_n - 1}$，这是因为其为满足 $s[0\\cdots i-1]&#x3D;s[n-i+1\\cdots n]$ 的次大 $i$。</p>\n<p>这样一来，我们就可以得到一个 $O(n)$ 的算法了。</p>\n<h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><pre><code class=\"cpp\">void prefix_funtion(std::string s) &#123;\n    int n = s.size();\n    vector&lt;int&gt; pi(n);\n    for (int i = 1; i &lt; n; i++) &#123;\n        int j = pi[j - 1];\n        while (j &amp;&amp; s[j] != s[i])\n            j = pi[j - 1];\n        if (s[i] == s[j])\n            j++;\n        pi[i] = j;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"KMP-算法\"><a href=\"#KMP-算法\" class=\"headerlink\" title=\"KMP 算法\"></a>KMP 算法</h3><h4 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h4><p>给定一个文本串 $t$ 与模式串 $s$，尝试找到 $s$ 在 $t$ 中的所有出现。</p>\n<h4 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h4><p>考虑问题的本质：是否在 $t$ 中存在一段 $t[i\\cdots i+n-1]$ 使得其与 $s$ 完全相等，显然，这可以转化为一个求前缀函数的问题，构造字符串<br>$$s+#+t$$<br>其中 $#$ 代表一个无义分隔符。接下来，考虑在 $n+1$ 之后的区域考虑前缀函数，显然，找到匹配当且仅当 $\\pi_i&#x3D;n$。</p>\n<h3 id=\"求字符串的周期\"><a href=\"#求字符串的周期\" class=\"headerlink\" title=\"求字符串的周期\"></a>求字符串的周期</h3><p>若字符串内存在一个 $l$ 的周期，则显然其有一段长度为 $n-l$ 的相等前后缀。于是，根据求前缀函数的方式可以找到 $s$ 的最小周期，通过失配优化可以找到其所有周期。</p>\n<h3 id=\"统计每个前缀的出现次数\"><a href=\"#统计每个前缀的出现次数\" class=\"headerlink\" title=\"统计每个前缀的出现次数\"></a>统计每个前缀的出现次数</h3><p>寻找 $s$ 的每一个前缀的出现次数，朴素方法是跑 $n$ 次 KMP，时间复杂度在平方量级，但是通过失配优化，很容易变成线性。</p>\n<h3 id=\"字符串压缩\"><a href=\"#字符串压缩\" class=\"headerlink\" title=\"字符串压缩\"></a>字符串压缩</h3><p>与字符串周期是类同的，证明比较烦。</p>\n<h3 id=\"构建自动机\"><a href=\"#构建自动机\" class=\"headerlink\" title=\"构建自动机\"></a>构建自动机</h3><p>先咕。</p>\n",
            "tags": []
        }
    ]
}