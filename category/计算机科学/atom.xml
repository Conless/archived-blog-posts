<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://conless.dev/blog</id>
    <title>Conless&#39; Blog • Posts by &#34;计算机科学&#34; category</title>
    <link href="https://conless.dev/blog" />
    <updated>2023-01-27T06:03:43.000Z</updated>
    <entry>
        <id>https://conless.dev/blog/cs/shulian-poufen/</id>
        <title>数据结构复健（一）：树链剖分 (updating)</title>
        <link rel="alternate" href="https://conless.dev/blog/cs/shulian-poufen/"/>
        <content type="html">&lt;h2 id=&#34;学习计划&#34;&gt;&lt;a href=&#34;#学习计划&#34; class=&#34;headerlink&#34; title=&#34;学习计划&#34;&gt;&lt;/a&gt;学习计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;事项&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;详情&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;重温基本概念&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;参考课本与 OI-wiki&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;基础题目练习&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;复习 P2590,P2146,P3178，完成 P4427,ACMOJ1473&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2.5h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;概念细节与拓展&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;课本，OI-wiki，完成或学习 P1505 &amp;#x2F; P3979&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2.5h&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;思想&#34;&gt;&lt;a href=&#34;#思想&#34; class=&#34;headerlink&#34; title=&#34;思想&#34;&gt;&lt;/a&gt;思想&lt;/h2&gt;&lt;p&gt;将一棵树划分为若干条链，转化为线性结构，从而用其它数据结构维护相关信息。&lt;/p&gt;
&lt;p&gt;重链剖分可以将树上的任意一条路径划分成不超过 $O(\log n)$ 条连续的链，每条链上的点深度互不相同（即是自底向上的一条链，链上所有点的 LCA 为链的一个端点）。&lt;/p&gt;
&lt;p&gt;重链剖分还能保证划分出的每条链上的节点 DFS 序连续，因此可以方便地用一些维护序列的数据结构（如线段树）来维护树上路径的信息。&lt;/p&gt;
&lt;h2 id=&#34;重链剖分&#34;&gt;&lt;a href=&#34;#重链剖分&#34; class=&#34;headerlink&#34; title=&#34;重链剖分&#34;&gt;&lt;/a&gt;重链剖分&lt;/h2&gt;&lt;p&gt;重链剖分是最常用的树链剖分方式：&lt;/p&gt;
&lt;p&gt;定义 重子节点 表示其子节点中子树最大的子结点。如果有多个子树最大的子结点，取其一。如果没有子节点，就无重子节点。&lt;/p&gt;
&lt;p&gt;定义 轻子节点 表示剩余的所有子结点。&lt;/p&gt;
&lt;p&gt;从这个结点到重子节点的边为 重边。&lt;/p&gt;
&lt;p&gt;到其他轻子节点的边为 轻边。&lt;/p&gt;
&lt;p&gt;若干条首尾衔接的重边构成 重链。&lt;/p&gt;
&lt;p&gt;把落单的结点也当作重链，那么整棵树就被剖分成若干条重链。&lt;/p&gt;
&lt;h2 id=&#34;实现&#34;&gt;&lt;a href=&#34;#实现&#34; class=&#34;headerlink&#34; title=&#34;实现&#34;&gt;&lt;/a&gt;实现&lt;/h2&gt;&lt;p&gt;运用到的数据结构为支持 单点&amp;#x2F;区间 修改&amp;#x2F;查询 的线段树，记作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;sjtu::SegmentTree&amp;lt;int, MAXN&amp;gt; stree;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先进行两遍 dfs 建树&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;void dfs(int u, int last) &amp;#123;
    int maxsiz = 0;
    siz[u] = 1;
    fa[u] = last;
    for (int i = head[u]; i; i = edge[i].next) &amp;#123;
        int v = edge[i].v;
        if (v == last)
            continue;
        h[v] = h[u] + 1;
        dfs(v, u);
        siz[u] += siz[v];
        if (siz[v] &amp;gt; maxsiz) &amp;#123;
            maxsiz = siz[v];
            mson[u] = v;
        &amp;#125;
    &amp;#125;
&amp;#125;

void build(int u, int last, int top) &amp;#123;
    key[u] = ++ti;
    tp[u] = top;
    data[ti] = w[u];
    if (mson[u])
        build(mson[u], u, top);
    for (int i = head[u]; i; i = edge[i].next) &amp;#123;
        int v = edge[i].v;
        if (v == last || v == mson[u])
            continue;
        build(v, u, v);
    &amp;#125;
    las[u] = ti;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2023-01-27T06:03:43.000Z</updated>
    </entry>
</feed>
