{
    "version": "https://jsonfeed.org/version/1",
    "title": "夢の日記 • All posts by \"计算机科学\" category",
    "description": "Stay hungry. Stay foolish.",
    "home_page_url": "https://conless.dev/blog",
    "items": [
        {
            "id": "https://conless.dev/blog/cs/shulian-poufen/",
            "url": "https://conless.dev/blog/cs/shulian-poufen/",
            "title": "数据结构复健（一）：树链剖分 (updating)",
            "date_published": "2023-01-27T06:03:43.000Z",
            "content_html": "<h2 id=\"学习计划\"><a href=\"#学习计划\" class=\"headerlink\" title=\"学习计划\"></a>学习计划</h2><table>\n<thead>\n<tr>\n<th align=\"center\">事项</th>\n<th align=\"center\">详情</th>\n<th align=\"center\">时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">重温基本概念</td>\n<td align=\"center\">参考课本与 OI-wiki</td>\n<td align=\"center\">1h</td>\n</tr>\n<tr>\n<td align=\"center\">基础题目练习</td>\n<td align=\"center\">复习 P2590,P2146,P3178，完成 P4427,ACMOJ1473</td>\n<td align=\"center\">2.5h</td>\n</tr>\n<tr>\n<td align=\"center\">概念细节与拓展</td>\n<td align=\"center\">课本，OI-wiki，完成或学习 P1505 &#x2F; P3979</td>\n<td align=\"center\">2.5h</td>\n</tr>\n</tbody></table>\n<h2 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h2><p>将一棵树划分为若干条链，转化为线性结构，从而用其它数据结构维护相关信息。</p>\n<p>重链剖分可以将树上的任意一条路径划分成不超过 $O(\\log n)$ 条连续的链，每条链上的点深度互不相同（即是自底向上的一条链，链上所有点的 LCA 为链的一个端点）。</p>\n<p>重链剖分还能保证划分出的每条链上的节点 DFS 序连续，因此可以方便地用一些维护序列的数据结构（如线段树）来维护树上路径的信息。</p>\n<h2 id=\"重链剖分\"><a href=\"#重链剖分\" class=\"headerlink\" title=\"重链剖分\"></a>重链剖分</h2><p>重链剖分是最常用的树链剖分方式：</p>\n<p>定义 重子节点 表示其子节点中子树最大的子结点。如果有多个子树最大的子结点，取其一。如果没有子节点，就无重子节点。</p>\n<p>定义 轻子节点 表示剩余的所有子结点。</p>\n<p>从这个结点到重子节点的边为 重边。</p>\n<p>到其他轻子节点的边为 轻边。</p>\n<p>若干条首尾衔接的重边构成 重链。</p>\n<p>把落单的结点也当作重链，那么整棵树就被剖分成若干条重链。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>运用到的数据结构为支持 单点&#x2F;区间 修改&#x2F;查询 的线段树，记作</p>\n<pre><code class=\"cpp\">sjtu::SegmentTree&lt;int, MAXN&gt; stree;\n</code></pre>\n<p>首先进行两遍 dfs 建树</p>\n<pre><code class=\"cpp\">void dfs(int u, int last) &#123;\n    int maxsiz = 0;\n    siz[u] = 1;\n    fa[u] = last;\n    for (int i = head[u]; i; i = edge[i].next) &#123;\n        int v = edge[i].v;\n        if (v == last)\n            continue;\n        h[v] = h[u] + 1;\n        dfs(v, u);\n        siz[u] += siz[v];\n        if (siz[v] &gt; maxsiz) &#123;\n            maxsiz = siz[v];\n            mson[u] = v;\n        &#125;\n    &#125;\n&#125;\n\nvoid build(int u, int last, int top) &#123;\n    key[u] = ++ti;\n    tp[u] = top;\n    data[ti] = w[u];\n    if (mson[u])\n        build(mson[u], u, top);\n    for (int i = head[u]; i; i = edge[i].next) &#123;\n        int v = edge[i].v;\n        if (v == last || v == mson[u])\n            continue;\n        build(v, u, v);\n    &#125;\n    las[u] = ti;\n&#125;\n</code></pre>\n",
            "tags": []
        }
    ]
}